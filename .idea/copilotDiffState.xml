<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/retailassistant/features/invoices/detail/InvoiceDetailViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/retailassistant/features/invoices/detail/InvoiceDetailViewModel.kt" />
              <option name="originalContent" value="package com.retailassistant.features.invoices.detail&#10;import androidx.lifecycle.viewModelScope&#10;import com.retailassistant.core.MviViewModel&#10;import com.retailassistant.core.UiAction&#10;import com.retailassistant.core.UiEvent&#10;import com.retailassistant.core.UiState&#10;import com.retailassistant.data.db.Customer&#10;import com.retailassistant.data.db.InteractionLog&#10;import com.retailassistant.data.db.Invoice&#10;import com.retailassistant.data.repository.RetailRepository&#10;import io.github.jan.supabase.SupabaseClient&#10;import io.github.jan.supabase.auth.auth&#10;import kotlinx.coroutines.flow.filterNotNull&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.flow.launchIn&#10;import kotlinx.coroutines.flow.onEach&#10;import kotlinx.coroutines.launch&#10;import java.time.LocalDate&#10;sealed class ActiveDialog {&#10;    data object AddPayment : ActiveDialog()&#10;    data object AddNote : ActiveDialog()&#10;    data object Postpone : ActiveDialog()&#10;    data object ConfirmDeleteInvoice : ActiveDialog()&#10;}&#10;data class InvoiceDetailState(&#10;    val invoice: Invoice? = null,&#10;    val customer: Customer? = null,&#10;    val logs: List&lt;InteractionLog&gt; = emptyList(),&#10;    val imageUrl: String? = null,&#10;    val isLoading: Boolean = true,&#10;    val isProcessingAction: Boolean = false, // For dialog actions&#10;    val activeDialog: ActiveDialog? = null,&#10;) : UiState&#10;sealed interface InvoiceDetailAction : UiAction {&#10;    // Internal actions for loading data&#10;    data class DetailsLoaded(val invoice: Invoice, val logs: List&lt;InteractionLog&gt;) : InvoiceDetailAction&#10;    data class CustomerLoaded(val customer: Customer) : InvoiceDetailAction&#10;    data class ImageUrlLoaded(val url: String) : InvoiceDetailAction&#10;    data class LoadFailed(val error: Throwable) : InvoiceDetailAction&#10;    // User-initiated actions&#10;    object CallCustomer : InvoiceDetailAction&#10;    data class ShowDialog(val dialog: ActiveDialog?) : InvoiceDetailAction&#10;    data class AddPayment(val amount: Double, val note: String?) : InvoiceDetailAction&#10;    data class AddNote(val note: String) : InvoiceDetailAction&#10;    data class PostponeDueDate(val newDueDate: LocalDate, val reason: String?) : InvoiceDetailAction&#10;    object DeleteInvoice : InvoiceDetailAction&#10;    data class ShowMessage(val message: String) : InvoiceDetailAction&#10;}&#10;sealed interface InvoiceDetailEvent : UiEvent {&#10;    data class ShowMessage(val message: String) : UiEvent&#10;    data class MakePhoneCall(val phoneNumber: String) : UiEvent&#10;    object NavigateBack : UiEvent&#10;}&#10;class InvoiceDetailViewModel(&#10;    private val invoiceId: String,&#10;    private val repository: RetailRepository,&#10;    private val supabase: SupabaseClient&#10;) : MviViewModel&lt;InvoiceDetailState, InvoiceDetailAction, InvoiceDetailEvent&gt;() {&#10;    private val userId: String? = supabase.auth.currentUserOrNull()?.id&#10;    init {&#10;        // FIX: Consolidated data loading into a single, more robust stream&#10;        repository.getInvoiceWithDetails(invoiceId)&#10;            .onEach { (invoice, logs) -&gt;&#10;                if (invoice != null) {&#10;                    // Once invoice is confirmed to exist, load its related data&#10;                    sendAction(InvoiceDetailAction.DetailsLoaded(invoice, logs))&#10;                    loadCustomer(invoice.customerId)&#10;                    loadImageUrl(invoice.originalScanUrl)&#10;                } else if (!uiState.value.isLoading) {&#10;                    // This handles the case where the invoice is deleted while the user is viewing it&#10;                    sendEvent(InvoiceDetailEvent.NavigateBack)&#10;                } else {&#10;                    // This handles the case where the invoice ID was invalid from the start&#10;                    setState { copy(isLoading = false) }&#10;                }&#10;            }&#10;            .launchIn(viewModelScope)&#10;    }&#10;    private fun loadCustomer(customerId: String) = viewModelScope.launch {&#10;        repository.getCustomerById(customerId)&#10;            .filterNotNull()&#10;            .first() // Take the first non-null emission&#10;            .let { sendAction(InvoiceDetailAction.CustomerLoaded(it)) }&#10;    }&#10;    private fun loadImageUrl(path: String) = viewModelScope.launch {&#10;        // Prevent re-fetching if URL is already loaded&#10;        if (uiState.value.imageUrl != null) return@launch&#10;        repository.getPublicUrl(path)&#10;            .onSuccess { sendAction(InvoiceDetailAction.ImageUrlLoaded(it)) }&#10;            .onFailure { sendAction(InvoiceDetailAction.LoadFailed(it)) }&#10;    }&#10;    override fun createInitialState(): InvoiceDetailState = InvoiceDetailState()&#10;    override fun handleAction(action: InvoiceDetailAction) {&#10;        when (action) {&#10;            is InvoiceDetailAction.DetailsLoaded -&gt; setState { copy(invoice = action.invoice, logs = action.logs, isLoading = false) }&#10;            is InvoiceDetailAction.CustomerLoaded -&gt; setState { copy(customer = action.customer) }&#10;            is InvoiceDetailAction.ImageUrlLoaded -&gt; setState { copy(imageUrl = action.url) }&#10;            is InvoiceDetailAction.LoadFailed -&gt; sendEvent(InvoiceDetailEvent.ShowMessage(action.error.message ?: &quot;Failed to load image&quot;))&#10;            is InvoiceDetailAction.AddPayment -&gt; addPayment(action.amount, action.note)&#10;            is InvoiceDetailAction.AddNote -&gt; addNote(action.note)&#10;            is InvoiceDetailAction.PostponeDueDate -&gt; postponeDueDate(action.newDueDate, action.reason)&#10;            is InvoiceDetailAction.CallCustomer -&gt; callCustomer()&#10;            is InvoiceDetailAction.ShowDialog -&gt; setState { copy(activeDialog = action.dialog, isProcessingAction = false) }&#10;            is InvoiceDetailAction.DeleteInvoice -&gt; deleteInvoice()&#10;            is InvoiceDetailAction.ShowMessage -&gt; sendEvent(InvoiceDetailEvent.ShowMessage(action.message))&#10;        }&#10;    }&#10;    private fun performAction(&#10;        repoCall: suspend () -&gt; Result&lt;Unit&gt;,&#10;        successMessage: String? = &quot;Action completed successfully.&quot;,&#10;        onSuccess: (() -&gt; Unit)? = null&#10;    ) {&#10;        viewModelScope.launch {&#10;            setState { copy(isProcessingAction = true) }&#10;            val result = repoCall()&#10;            result.onSuccess {&#10;                if (successMessage != null) sendEvent(InvoiceDetailEvent.ShowMessage(successMessage))&#10;                onSuccess?.invoke()&#10;            }.onFailure {&#10;                sendEvent(InvoiceDetailEvent.ShowMessage(it.message ?: &quot;An error occurred&quot;))&#10;            }&#10;            setState { copy(isProcessingAction = false, activeDialog = null) }&#10;        }&#10;    }&#10;    private fun addPayment(amount: Double, note: String?) {&#10;        if (userId == null) return&#10;        if (amount &lt;= 0) {&#10;            sendEvent(InvoiceDetailEvent.ShowMessage(&quot;Payment amount must be positive.&quot;))&#10;            return&#10;        }&#10;        performAction(repoCall = { repository.addPayment(userId, invoiceId, amount, note) })&#10;    }&#10;    private fun addNote(note: String) {&#10;        if (userId == null) return&#10;        if (note.isBlank()) {&#10;            sendEvent(InvoiceDetailEvent.ShowMessage(&quot;Note cannot be empty.&quot;))&#10;            return&#10;        }&#10;        performAction(repoCall = { repository.addNote(userId, invoiceId, note) })&#10;    }&#10;    private fun postponeDueDate(newDueDate: LocalDate, reason: String?) {&#10;        if (userId == null) return&#10;        performAction(repoCall = { repository.postponeDueDate(userId, invoiceId, newDueDate, reason) })&#10;    }&#10;    private fun deleteInvoice() {&#10;        performAction(&#10;            repoCall = { repository.deleteInvoice(invoiceId) },&#10;            successMessage = &quot;Invoice deleted successfully.&quot;,&#10;            onSuccess = { sendEvent(InvoiceDetailEvent.NavigateBack) }&#10;        )&#10;    }&#10;    private fun callCustomer() {&#10;        uiState.value.customer?.phone?.takeIf { it.isNotBlank() }&#10;            ?.let { phone -&gt; sendEvent(InvoiceDetailEvent.MakePhoneCall(phone)) }&#10;            ?: sendEvent(InvoiceDetailEvent.ShowMessage(&quot;Customer has no phone number.&quot;))&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.retailassistant.features.invoices.detail&#10;import androidx.lifecycle.viewModelScope&#10;import com.retailassistant.core.MviViewModel&#10;import com.retailassistant.core.UiAction&#10;import com.retailassistant.core.UiEvent&#10;import com.retailassistant.core.UiState&#10;import com.retailassistant.data.db.Customer&#10;import com.retailassistant.data.db.InteractionLog&#10;import com.retailassistant.data.db.Invoice&#10;import com.retailassistant.data.repository.RetailRepository&#10;import io.github.jan.supabase.SupabaseClient&#10;import io.github.jan.supabase.auth.auth&#10;import kotlinx.coroutines.flow.filterNotNull&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.flow.launchIn&#10;import kotlinx.coroutines.flow.onEach&#10;import kotlinx.coroutines.launch&#10;import java.time.LocalDate&#10;sealed class ActiveDialog {&#10;    data object AddPayment : ActiveDialog()&#10;    data object AddNote : ActiveDialog()&#10;    data object Postpone : ActiveDialog()&#10;    data object ConfirmDeleteInvoice : ActiveDialog()&#10;}&#10;data class InvoiceDetailState(&#10;    val invoice: Invoice? = null,&#10;    val customer: Customer? = null,&#10;    val logs: List&lt;InteractionLog&gt; = emptyList(),&#10;    val imageUrl: String? = null,&#10;    val isLoading: Boolean = true,&#10;    val isProcessingAction: Boolean = false, // For dialog actions&#10;    val activeDialog: ActiveDialog? = null,&#10;) : UiState&#10;sealed interface InvoiceDetailAction : UiAction {&#10;    // Internal actions for loading data&#10;    data class DetailsLoaded(val invoice: Invoice, val logs: List&lt;InteractionLog&gt;) : InvoiceDetailAction&#10;    data class CustomerLoaded(val customer: Customer) : InvoiceDetailAction&#10;    data class ImageUrlLoaded(val url: String) : InvoiceDetailAction&#10;    data class LoadFailed(val error: Throwable) : InvoiceDetailAction&#10;    // User-initiated actions&#10;    object CallCustomer : InvoiceDetailAction&#10;    data class ShowDialog(val dialog: ActiveDialog?) : InvoiceDetailAction&#10;    data class AddPayment(val amount: Double, val note: String?) : InvoiceDetailAction&#10;    data class AddNote(val note: String) : InvoiceDetailAction&#10;    data class PostponeDueDate(val newDueDate: LocalDate, val reason: String?) : InvoiceDetailAction&#10;    object DeleteInvoice : InvoiceDetailAction&#10;    data class ShowMessage(val message: String) : InvoiceDetailAction&#10;}&#10;sealed interface InvoiceDetailEvent : UiEvent {&#10;    data class ShowMessage(val message: String) : InvoiceDetailEvent&#10;    data class MakePhoneCall(val phoneNumber: String) : InvoiceDetailEvent&#10;    object NavigateBack : InvoiceDetailEvent&#10;}&#10;class InvoiceDetailViewModel(&#10;    private val invoiceId: String,&#10;    private val repository: RetailRepository,&#10;    private val supabase: SupabaseClient&#10;) : MviViewModel&lt;InvoiceDetailState, InvoiceDetailAction, InvoiceDetailEvent&gt;() {&#10;    private val userId: String? = supabase.auth.currentUserOrNull()?.id&#10;    init {&#10;        // FIX: Consolidated data loading into a single, more robust stream&#10;        repository.getInvoiceWithDetails(invoiceId)&#10;            .onEach { (invoice, logs) -&gt;&#10;                if (invoice != null) {&#10;                    // Once invoice is confirmed to exist, load its related data&#10;                    sendAction(InvoiceDetailAction.DetailsLoaded(invoice, logs))&#10;                    loadCustomer(invoice.customerId)&#10;                    loadImageUrl(invoice.originalScanUrl)&#10;                } else if (!uiState.value.isLoading) {&#10;                    // This handles the case where the invoice is deleted while the user is viewing it&#10;                    sendEvent(InvoiceDetailEvent.NavigateBack)&#10;                } else {&#10;                    // This handles the case where the invoice ID was invalid from the start&#10;                    setState { copy(isLoading = false) }&#10;                }&#10;            }&#10;            .launchIn(viewModelScope)&#10;    }&#10;    private fun loadCustomer(customerId: String) = viewModelScope.launch {&#10;        repository.getCustomerById(customerId)&#10;            .filterNotNull()&#10;            .first() // Take the first non-null emission&#10;            .let { sendAction(InvoiceDetailAction.CustomerLoaded(it)) }&#10;    }&#10;    private fun loadImageUrl(path: String) = viewModelScope.launch {&#10;        // Prevent re-fetching if URL is already loaded&#10;        if (uiState.value.imageUrl != null) return@launch&#10;        repository.getPublicUrl(path)&#10;            .onSuccess { sendAction(InvoiceDetailAction.ImageUrlLoaded(it)) }&#10;            .onFailure { sendAction(InvoiceDetailAction.LoadFailed(it)) }&#10;    }&#10;    override fun createInitialState(): InvoiceDetailState = InvoiceDetailState()&#10;    override fun handleAction(action: InvoiceDetailAction) {&#10;        when (action) {&#10;            is InvoiceDetailAction.DetailsLoaded -&gt; setState { copy(invoice = action.invoice, logs = action.logs, isLoading = false) }&#10;            is InvoiceDetailAction.CustomerLoaded -&gt; setState { copy(customer = action.customer) }&#10;            is InvoiceDetailAction.ImageUrlLoaded -&gt; setState { copy(imageUrl = action.url) }&#10;            is InvoiceDetailAction.LoadFailed -&gt; sendEvent(InvoiceDetailEvent.ShowMessage(action.error.message ?: &quot;Failed to load image&quot;))&#10;            is InvoiceDetailAction.AddPayment -&gt; addPayment(action.amount, action.note)&#10;            is InvoiceDetailAction.AddNote -&gt; addNote(action.note)&#10;            is InvoiceDetailAction.PostponeDueDate -&gt; postponeDueDate(action.newDueDate, action.reason)&#10;            is InvoiceDetailAction.CallCustomer -&gt; callCustomer()&#10;            is InvoiceDetailAction.ShowDialog -&gt; setState { copy(activeDialog = action.dialog, isProcessingAction = false) }&#10;            is InvoiceDetailAction.DeleteInvoice -&gt; deleteInvoice()&#10;            is InvoiceDetailAction.ShowMessage -&gt; sendEvent(InvoiceDetailEvent.ShowMessage(action.message))&#10;        }&#10;    }&#10;    private fun performAction(&#10;        repoCall: suspend () -&gt; Result&lt;Unit&gt;,&#10;        successMessage: String? = &quot;Action completed successfully.&quot;,&#10;        onSuccess: (() -&gt; Unit)? = null&#10;    ) {&#10;        viewModelScope.launch {&#10;            setState { copy(isProcessingAction = true) }&#10;            val result = repoCall()&#10;            result.onSuccess {&#10;                if (successMessage != null) sendEvent(InvoiceDetailEvent.ShowMessage(successMessage))&#10;                onSuccess?.invoke()&#10;            }.onFailure {&#10;                sendEvent(InvoiceDetailEvent.ShowMessage(it.message ?: &quot;An error occurred&quot;))&#10;            }&#10;            setState { copy(isProcessingAction = false, activeDialog = null) }&#10;        }&#10;    }&#10;    private fun addPayment(amount: Double, note: String?) {&#10;        if (userId == null) return&#10;        if (amount &lt;= 0) {&#10;            sendEvent(InvoiceDetailEvent.ShowMessage(&quot;Payment amount must be positive.&quot;))&#10;            return&#10;        }&#10;        performAction(repoCall = { repository.addPayment(userId, invoiceId, amount, note) })&#10;    }&#10;    private fun addNote(note: String) {&#10;        if (userId == null) return&#10;        if (note.isBlank()) {&#10;            sendEvent(InvoiceDetailEvent.ShowMessage(&quot;Note cannot be empty.&quot;))&#10;            return&#10;        }&#10;        performAction(repoCall = { repository.addNote(userId, invoiceId, note) })&#10;    }&#10;    private fun postponeDueDate(newDueDate: LocalDate, reason: String?) {&#10;        if (userId == null) return&#10;        performAction(repoCall = { repository.postponeDueDate(userId, invoiceId, newDueDate, reason) })&#10;    }&#10;    private fun deleteInvoice() {&#10;        performAction(&#10;            repoCall = { repository.deleteInvoice(invoiceId) },&#10;            successMessage = &quot;Invoice deleted successfully.&quot;,&#10;            onSuccess = { sendEvent(InvoiceDetailEvent.NavigateBack) }&#10;        )&#10;    }&#10;    private fun callCustomer() {&#10;        uiState.value.customer?.phone?.takeIf { it.isNotBlank() }&#10;            ?.let { phone -&gt; sendEvent(InvoiceDetailEvent.MakePhoneCall(phone)) }&#10;            ?: sendEvent(InvoiceDetailEvent.ShowMessage(&quot;Customer has no phone number.&quot;))&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>